<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>SententialLogic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SententialLogic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import re


class Truth:
    &#34;&#34;&#34;
    Basic truth check class.
    &#34;&#34;&#34;

    interpreter = None

    def __init__(self, interpretingExample=None):
        &#34;&#34;&#34;
        Given an example object, which should be able to support interpretion
        of propopsitions, its type will be stored as interpreter. Defaults to
        `None`, could be an `Version` object out of `macwinnie_pyhelpers.Version`
        &#34;&#34;&#34;
        self.interpreter = type(interpretingExample)

    def verify(self, proposition):
        &#34;&#34;&#34;
        * boolean propositions will be returned as they are
        * numbers (float, integers) will return true if &gt; 0, 0 and negatives will return false
        * `nein`, `no`, `n`, `falsch`, `false`, `f` will return `False`
        * `ja`, `j`, `yes`, `y`, `wahr`, `w`, `true`, `t` will return `True`
        &#34;&#34;&#34;
        trueMatch = r&#34;^((t(rue)?)|(y(es)?)|(w(ahr)?)|(j(a)?))$&#34;
        falseMatch = r&#34;^((f((alse)|(alsch))?)|(n((o)|(ein))?))$&#34;
        if type(proposition) is bool:
            return proposition
        elif isinstance(proposition, (int, float)):
            return proposition &gt; 0
        elif type(proposition) is str:
            if re.match(trueMatch, proposition.strip(), re.IGNORECASE):
                return True
            elif re.match(falseMatch, proposition.strip(), re.IGNORECASE):
                return False
            elif self.interpreter != None:
                try:
                    return self.interpret(proposition)
                except:
                    pass
        raise Exception(&#39;No interpretion found for given proposition &#34;{}&#34;!&#39;.format(proposition))

    def interpret(self, proposition):
        &#34;&#34;&#34;
        Method for deep-diving proposition interpretation.
        Will check for `P1 o P2` with `P1`, `P2` propositions and `o` an operator
        out of:
        * `&lt;=` for “less or equal”
        * `&lt;` for “less”
        * `&gt;=` for “greater or equal”
        * `&gt;` for “greater”
        * `!=` for “not equal”
        * `==` for “equal”
        &#34;&#34;&#34;
        rx = r&#34;((((&lt;|&gt;)=?)|(!|=)=))&#34;
        cRx = re.compile(rx)
        splitting = []
        foundOperators = cRx.finditer(proposition)
        for idx, match in enumerate(foundOperators):
            s = match.start()
            e = match.end()
            splitting.append([s, e])
        checks = []
        s3 = 0
        for i, s in enumerate(splitting):
            s1 = s3
            s2 = s[0]
            s3 = s[1]
            if i != len(splitting) - 1:
                s4 = splitting[i + 1][0]
            else:
                s4 = len(proposition)
            checks.append(
                [
                    proposition[s1:s2].strip(),
                    proposition[s2:s3].strip(),
                    proposition[s3:s4].strip(),
                ]
            )
        verum = True
        for c in checks:
            o0 = self.interpreter(c[0])
            o1 = self.interpreter(c[2])
            if c[1] == &#34;&lt;=&#34;:
                verum = verum and o0 &lt;= o1
            elif c[1] == &#34;&lt;&#34;:
                verum = verum and o0 &lt; o1
            elif c[1] == &#34;&gt;=&#34;:
                verum = verum and o0 &gt;= o1
            elif c[1] == &#34;&gt;&#34;:
                verum = verum and o0 &gt; o1
            elif c[1] == &#34;!=&#34;:
                verum = verum and o0 != o1
            elif c[1] == &#34;==&#34;:
                verum = verum and o0 == o1
            else:
                raise Exception(&#39;&#34;{}&#34; is not interpretable!&#39;.format(proposition))
        return verum


class Sentence:
    &#34;&#34;&#34;
    String to be checked for truth.

    Binding can be done using regular brackets `(` and `)` – and
    the operators binding order.

    Operators supported are (top is more binding than bottom):
    * `¬` as `not`
    * `∧` as `and`
    * `∨` as `or` (not the letter `v`!)
    &#34;&#34;&#34;

    sentence = None
    tsentence = None
    verifier = None
    atomized = None

    def __init__(self, sentence, interpretingExample=None, verifier=None, pretested=False):
        &#34;&#34;&#34;
        Given a `sentence`, this classes objects will be used to verify a logical
        sentence.

        With an `interpreter` defined and `verifier` not set – may be the string
        `Version` to use the same named class from this package or `int` or
        something like that – the `verifier` from this package `Truth` will be
        instanciated.

        `verifier` has to be an instance of a class implementing a method `verify`
        which returns boolean values for string input.

        `pretested` is to be used internally - when all propositions have
        already been replaced by truthy literals.
        &#34;&#34;&#34;
        self.sentence = sentence
        if not pretested:
            if verifier == None:
                if type(interpretingExample) == type(None):
                    self.verifier = Truth()
                else:
                    self.verifier = Truth(interpretingExample)
            else:
                self.verifier = verifier
            self.verifyAllPropositions()
        else:
            self.tsentence = sentence
        self.atomizeBraces()

    def getLiteral(self, booleanValue):
        &#34;&#34;&#34;Somehow static function to get a literal for boolean values&#34;&#34;&#34;
        if booleanValue:
            return &#34;⊤&#34;
        else:
            return &#34;⊥&#34;

    def verifyAllPropositions(self):
        &#34;&#34;&#34;Turn all propositions into `⊤` for truthy and `⊥` for false values&#34;&#34;&#34;
        deviders = r&#34;([^(¬∧∨\(\)]+)&#34;
        verified = []
        self.tsentence = self.sentence
        for p in re.findall(deviders, self.tsentence):
            x = p.strip()
            if x not in verified and len(x) &gt; 0:
                self.tsentence = self.tsentence.replace(
                    p, self.getLiteral(self.verifier.verify(x.strip()))
                )
        self.tsentence = re.sub(r&#34;\s&#34;, &#34;&#34;, self.tsentence)

    def truth(self):
        &#34;&#34;&#34;Final method that returns the truth value of a sentence&#34;&#34;&#34;
        while not self.isAtomic():
            # do everything to do with ¬, as it has the stronges binding
            rx = r&#34;¬(.)&#34;
            x = re.search(rx, self.atomized)
            if x != None:
                literal = x.group(1)
                z = not Sentence(literal, verifier=self.verifier, pretested=True).truth()
                self.atomized = self.atomized.replace(x.group(0), self.getLiteral(z))
            else:
                # do everything to do with ∧, as it&#39;s the next after ¬
                rx = r&#34;(.)∧(.)&#34;
                x = re.search(rx, self.atomized)
                if x != None:
                    literalA = x.group(1)
                    literalB = x.group(2)
                    boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                    boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                    self.atomized = self.atomized.replace(
                        x.group(0), self.getLiteral(boolA and boolB)
                    )
                else:
                    # do everything to do with ∨, as it&#39;s the next after ∧
                    rx = r&#34;(.)∨(.)&#34;
                    x = re.search(rx, self.atomized)
                    if x != None:
                        literalA = x.group(1)
                        literalB = x.group(2)
                        boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                        boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                        self.atomized = self.atomized.replace(
                            x.group(0), self.getLiteral(boolA or boolB)
                        )
        if self.atomized == &#34;⊤&#34;:
            return True
        elif self.atomized == &#34;⊥&#34;:
            return False
        else:
            raise Exception(
                &#39;&#34;{}&#34; should be an atomic sentence – but it is not!&#39;.format(self.sentence)
            )

    def isAtomic(self):
        &#34;&#34;&#34;
        Check if the given sentence is a single, atomic literal so it can be translated to boolean
        &#34;&#34;&#34;
        if len(self.atomized) == 1:
            return True
        else:
            return False

    def getBraceIdx(self, openingCharRX=r&#34;\(&#34;, closingCharRX=r&#34;\)&#34;):
        &#34;&#34;&#34;Analyze sentence for brackets and return their type and index&#34;&#34;&#34;
        oRx = re.compile(openingCharRX)
        cRx = re.compile(closingCharRX)

        braces = {}
        for m in oRx.finditer(self.atomized):
            c = m.group()
            if len(c) != 1:
                raise Exception(&#34;Opening only has to match single characters!&#34;)
            braces[m.start()] = &#34;o&#34;

        for m in cRx.finditer(self.atomized):
            c = m.group()
            if len(c) != 1:
                raise Exception(&#34;Closing only has to match single characters!&#34;)
            braces[m.start()] = &#34;c&#34;

        brackets = {k: braces[k] for k in sorted(braces.keys())}

        idx = list(brackets.keys())
        if len(idx) &gt; 0:
            if brackets[idx[-1]] != &#34;c&#34;:
                raise Exception(&#34;Last bracket has to be a closing one!&#34;)

            if brackets[idx[0]] != &#34;o&#34;:
                raise Exception(&#34;First bracket has to be an opening one!&#34;)

        return brackets, idx

    def atomizeBraces(self):
        &#34;&#34;&#34;Find matching outer brackets as long as existent and get literals `⊤` or `⊥` for the inner sentence&#34;&#34;&#34;
        if self.atomized == None:
            self.atomized = self.tsentence
        br, idx = self.getBraceIdx()
        while len(idx) &gt; 0:
            i = 0
            z = 1
            x1 = idx[i]
            while z &gt; 0:
                i = i + 1
                if br[idx[i]] == &#34;o&#34;:
                    z = z + 1
                else:
                    z = z - 1
            x2 = idx[i] + 1
            toBeReplaced = self.atomized[x1:x2]
            subSentence = toBeReplaced[1:-1]
            self.atomized = self.atomized.replace(
                toBeReplaced,
                self.getLiteral(
                    Sentence(subSentence, verifier=self.verifier, pretested=True).truth()
                ),
            )
            br, idx = self.getBraceIdx()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SententialLogic.Sentence"><code class="flex name class">
<span>class <span class="ident">Sentence</span></span>
<span>(</span><span>sentence, interpretingExample=None, verifier=None, pretested=False)</span>
</code></dt>
<dd>
<div class="desc"><p>String to be checked for truth.</p>
<p>Binding can be done using regular brackets <code>(</code> and <code>)</code> – and
the operators binding order.</p>
<p>Operators supported are (top is more binding than bottom):
* <code>¬</code> as <code>not</code>
* <code>∧</code> as <code>and</code>
* <code>∨</code> as <code>or</code> (not the letter <code>v</code>!)</p>
<p>Given a <code>sentence</code>, this classes objects will be used to verify a logical
sentence.</p>
<p>With an <code>interpreter</code> defined and <code>verifier</code> not set – may be the string
<code>Version</code> to use the same named class from this package or <code>int</code> or
something like that – the <code>verifier</code> from this package <code><a title="SententialLogic.Truth" href="#SententialLogic.Truth">Truth</a></code> will be
instanciated.</p>
<p><code>verifier</code> has to be an instance of a class implementing a method <code>verify</code>
which returns boolean values for string input.</p>
<p><code>pretested</code> is to be used internally - when all propositions have
already been replaced by truthy literals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sentence:
    &#34;&#34;&#34;
    String to be checked for truth.

    Binding can be done using regular brackets `(` and `)` – and
    the operators binding order.

    Operators supported are (top is more binding than bottom):
    * `¬` as `not`
    * `∧` as `and`
    * `∨` as `or` (not the letter `v`!)
    &#34;&#34;&#34;

    sentence = None
    tsentence = None
    verifier = None
    atomized = None

    def __init__(self, sentence, interpretingExample=None, verifier=None, pretested=False):
        &#34;&#34;&#34;
        Given a `sentence`, this classes objects will be used to verify a logical
        sentence.

        With an `interpreter` defined and `verifier` not set – may be the string
        `Version` to use the same named class from this package or `int` or
        something like that – the `verifier` from this package `Truth` will be
        instanciated.

        `verifier` has to be an instance of a class implementing a method `verify`
        which returns boolean values for string input.

        `pretested` is to be used internally - when all propositions have
        already been replaced by truthy literals.
        &#34;&#34;&#34;
        self.sentence = sentence
        if not pretested:
            if verifier == None:
                if type(interpretingExample) == type(None):
                    self.verifier = Truth()
                else:
                    self.verifier = Truth(interpretingExample)
            else:
                self.verifier = verifier
            self.verifyAllPropositions()
        else:
            self.tsentence = sentence
        self.atomizeBraces()

    def getLiteral(self, booleanValue):
        &#34;&#34;&#34;Somehow static function to get a literal for boolean values&#34;&#34;&#34;
        if booleanValue:
            return &#34;⊤&#34;
        else:
            return &#34;⊥&#34;

    def verifyAllPropositions(self):
        &#34;&#34;&#34;Turn all propositions into `⊤` for truthy and `⊥` for false values&#34;&#34;&#34;
        deviders = r&#34;([^(¬∧∨\(\)]+)&#34;
        verified = []
        self.tsentence = self.sentence
        for p in re.findall(deviders, self.tsentence):
            x = p.strip()
            if x not in verified and len(x) &gt; 0:
                self.tsentence = self.tsentence.replace(
                    p, self.getLiteral(self.verifier.verify(x.strip()))
                )
        self.tsentence = re.sub(r&#34;\s&#34;, &#34;&#34;, self.tsentence)

    def truth(self):
        &#34;&#34;&#34;Final method that returns the truth value of a sentence&#34;&#34;&#34;
        while not self.isAtomic():
            # do everything to do with ¬, as it has the stronges binding
            rx = r&#34;¬(.)&#34;
            x = re.search(rx, self.atomized)
            if x != None:
                literal = x.group(1)
                z = not Sentence(literal, verifier=self.verifier, pretested=True).truth()
                self.atomized = self.atomized.replace(x.group(0), self.getLiteral(z))
            else:
                # do everything to do with ∧, as it&#39;s the next after ¬
                rx = r&#34;(.)∧(.)&#34;
                x = re.search(rx, self.atomized)
                if x != None:
                    literalA = x.group(1)
                    literalB = x.group(2)
                    boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                    boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                    self.atomized = self.atomized.replace(
                        x.group(0), self.getLiteral(boolA and boolB)
                    )
                else:
                    # do everything to do with ∨, as it&#39;s the next after ∧
                    rx = r&#34;(.)∨(.)&#34;
                    x = re.search(rx, self.atomized)
                    if x != None:
                        literalA = x.group(1)
                        literalB = x.group(2)
                        boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                        boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                        self.atomized = self.atomized.replace(
                            x.group(0), self.getLiteral(boolA or boolB)
                        )
        if self.atomized == &#34;⊤&#34;:
            return True
        elif self.atomized == &#34;⊥&#34;:
            return False
        else:
            raise Exception(
                &#39;&#34;{}&#34; should be an atomic sentence – but it is not!&#39;.format(self.sentence)
            )

    def isAtomic(self):
        &#34;&#34;&#34;
        Check if the given sentence is a single, atomic literal so it can be translated to boolean
        &#34;&#34;&#34;
        if len(self.atomized) == 1:
            return True
        else:
            return False

    def getBraceIdx(self, openingCharRX=r&#34;\(&#34;, closingCharRX=r&#34;\)&#34;):
        &#34;&#34;&#34;Analyze sentence for brackets and return their type and index&#34;&#34;&#34;
        oRx = re.compile(openingCharRX)
        cRx = re.compile(closingCharRX)

        braces = {}
        for m in oRx.finditer(self.atomized):
            c = m.group()
            if len(c) != 1:
                raise Exception(&#34;Opening only has to match single characters!&#34;)
            braces[m.start()] = &#34;o&#34;

        for m in cRx.finditer(self.atomized):
            c = m.group()
            if len(c) != 1:
                raise Exception(&#34;Closing only has to match single characters!&#34;)
            braces[m.start()] = &#34;c&#34;

        brackets = {k: braces[k] for k in sorted(braces.keys())}

        idx = list(brackets.keys())
        if len(idx) &gt; 0:
            if brackets[idx[-1]] != &#34;c&#34;:
                raise Exception(&#34;Last bracket has to be a closing one!&#34;)

            if brackets[idx[0]] != &#34;o&#34;:
                raise Exception(&#34;First bracket has to be an opening one!&#34;)

        return brackets, idx

    def atomizeBraces(self):
        &#34;&#34;&#34;Find matching outer brackets as long as existent and get literals `⊤` or `⊥` for the inner sentence&#34;&#34;&#34;
        if self.atomized == None:
            self.atomized = self.tsentence
        br, idx = self.getBraceIdx()
        while len(idx) &gt; 0:
            i = 0
            z = 1
            x1 = idx[i]
            while z &gt; 0:
                i = i + 1
                if br[idx[i]] == &#34;o&#34;:
                    z = z + 1
                else:
                    z = z - 1
            x2 = idx[i] + 1
            toBeReplaced = self.atomized[x1:x2]
            subSentence = toBeReplaced[1:-1]
            self.atomized = self.atomized.replace(
                toBeReplaced,
                self.getLiteral(
                    Sentence(subSentence, verifier=self.verifier, pretested=True).truth()
                ),
            )
            br, idx = self.getBraceIdx()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="SententialLogic.Sentence.atomized"><code class="name">var <span class="ident">atomized</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SententialLogic.Sentence.sentence"><code class="name">var <span class="ident">sentence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SententialLogic.Sentence.tsentence"><code class="name">var <span class="ident">tsentence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SententialLogic.Sentence.verifier"><code class="name">var <span class="ident">verifier</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SententialLogic.Sentence.atomizeBraces"><code class="name flex">
<span>def <span class="ident">atomizeBraces</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find matching outer brackets as long as existent and get literals <code>⊤</code> or <code>⊥</code> for the inner sentence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomizeBraces(self):
    &#34;&#34;&#34;Find matching outer brackets as long as existent and get literals `⊤` or `⊥` for the inner sentence&#34;&#34;&#34;
    if self.atomized == None:
        self.atomized = self.tsentence
    br, idx = self.getBraceIdx()
    while len(idx) &gt; 0:
        i = 0
        z = 1
        x1 = idx[i]
        while z &gt; 0:
            i = i + 1
            if br[idx[i]] == &#34;o&#34;:
                z = z + 1
            else:
                z = z - 1
        x2 = idx[i] + 1
        toBeReplaced = self.atomized[x1:x2]
        subSentence = toBeReplaced[1:-1]
        self.atomized = self.atomized.replace(
            toBeReplaced,
            self.getLiteral(
                Sentence(subSentence, verifier=self.verifier, pretested=True).truth()
            ),
        )
        br, idx = self.getBraceIdx()</code></pre>
</details>
</dd>
<dt id="SententialLogic.Sentence.getBraceIdx"><code class="name flex">
<span>def <span class="ident">getBraceIdx</span></span>(<span>self, openingCharRX='\\(', closingCharRX='\\)')</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze sentence for brackets and return their type and index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBraceIdx(self, openingCharRX=r&#34;\(&#34;, closingCharRX=r&#34;\)&#34;):
    &#34;&#34;&#34;Analyze sentence for brackets and return their type and index&#34;&#34;&#34;
    oRx = re.compile(openingCharRX)
    cRx = re.compile(closingCharRX)

    braces = {}
    for m in oRx.finditer(self.atomized):
        c = m.group()
        if len(c) != 1:
            raise Exception(&#34;Opening only has to match single characters!&#34;)
        braces[m.start()] = &#34;o&#34;

    for m in cRx.finditer(self.atomized):
        c = m.group()
        if len(c) != 1:
            raise Exception(&#34;Closing only has to match single characters!&#34;)
        braces[m.start()] = &#34;c&#34;

    brackets = {k: braces[k] for k in sorted(braces.keys())}

    idx = list(brackets.keys())
    if len(idx) &gt; 0:
        if brackets[idx[-1]] != &#34;c&#34;:
            raise Exception(&#34;Last bracket has to be a closing one!&#34;)

        if brackets[idx[0]] != &#34;o&#34;:
            raise Exception(&#34;First bracket has to be an opening one!&#34;)

    return brackets, idx</code></pre>
</details>
</dd>
<dt id="SententialLogic.Sentence.getLiteral"><code class="name flex">
<span>def <span class="ident">getLiteral</span></span>(<span>self, booleanValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Somehow static function to get a literal for boolean values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLiteral(self, booleanValue):
    &#34;&#34;&#34;Somehow static function to get a literal for boolean values&#34;&#34;&#34;
    if booleanValue:
        return &#34;⊤&#34;
    else:
        return &#34;⊥&#34;</code></pre>
</details>
</dd>
<dt id="SententialLogic.Sentence.isAtomic"><code class="name flex">
<span>def <span class="ident">isAtomic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the given sentence is a single, atomic literal so it can be translated to boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAtomic(self):
    &#34;&#34;&#34;
    Check if the given sentence is a single, atomic literal so it can be translated to boolean
    &#34;&#34;&#34;
    if len(self.atomized) == 1:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="SententialLogic.Sentence.truth"><code class="name flex">
<span>def <span class="ident">truth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Final method that returns the truth value of a sentence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truth(self):
    &#34;&#34;&#34;Final method that returns the truth value of a sentence&#34;&#34;&#34;
    while not self.isAtomic():
        # do everything to do with ¬, as it has the stronges binding
        rx = r&#34;¬(.)&#34;
        x = re.search(rx, self.atomized)
        if x != None:
            literal = x.group(1)
            z = not Sentence(literal, verifier=self.verifier, pretested=True).truth()
            self.atomized = self.atomized.replace(x.group(0), self.getLiteral(z))
        else:
            # do everything to do with ∧, as it&#39;s the next after ¬
            rx = r&#34;(.)∧(.)&#34;
            x = re.search(rx, self.atomized)
            if x != None:
                literalA = x.group(1)
                literalB = x.group(2)
                boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                self.atomized = self.atomized.replace(
                    x.group(0), self.getLiteral(boolA and boolB)
                )
            else:
                # do everything to do with ∨, as it&#39;s the next after ∧
                rx = r&#34;(.)∨(.)&#34;
                x = re.search(rx, self.atomized)
                if x != None:
                    literalA = x.group(1)
                    literalB = x.group(2)
                    boolA = Sentence(literalA, verifier=self.verifier, pretested=True).truth()
                    boolB = Sentence(literalB, verifier=self.verifier, pretested=True).truth()
                    self.atomized = self.atomized.replace(
                        x.group(0), self.getLiteral(boolA or boolB)
                    )
    if self.atomized == &#34;⊤&#34;:
        return True
    elif self.atomized == &#34;⊥&#34;:
        return False
    else:
        raise Exception(
            &#39;&#34;{}&#34; should be an atomic sentence – but it is not!&#39;.format(self.sentence)
        )</code></pre>
</details>
</dd>
<dt id="SententialLogic.Sentence.verifyAllPropositions"><code class="name flex">
<span>def <span class="ident">verifyAllPropositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn all propositions into <code>⊤</code> for truthy and <code>⊥</code> for false values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verifyAllPropositions(self):
    &#34;&#34;&#34;Turn all propositions into `⊤` for truthy and `⊥` for false values&#34;&#34;&#34;
    deviders = r&#34;([^(¬∧∨\(\)]+)&#34;
    verified = []
    self.tsentence = self.sentence
    for p in re.findall(deviders, self.tsentence):
        x = p.strip()
        if x not in verified and len(x) &gt; 0:
            self.tsentence = self.tsentence.replace(
                p, self.getLiteral(self.verifier.verify(x.strip()))
            )
    self.tsentence = re.sub(r&#34;\s&#34;, &#34;&#34;, self.tsentence)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="SententialLogic.Truth"><code class="flex name class">
<span>class <span class="ident">Truth</span></span>
<span>(</span><span>interpretingExample=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic truth check class.</p>
<p>Given an example object, which should be able to support interpretion
of propopsitions, its type will be stored as interpreter. Defaults to
<code>None</code>, could be an <code>Version</code> object out of <code>macwinnie_pyhelpers.Version</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Truth:
    &#34;&#34;&#34;
    Basic truth check class.
    &#34;&#34;&#34;

    interpreter = None

    def __init__(self, interpretingExample=None):
        &#34;&#34;&#34;
        Given an example object, which should be able to support interpretion
        of propopsitions, its type will be stored as interpreter. Defaults to
        `None`, could be an `Version` object out of `macwinnie_pyhelpers.Version`
        &#34;&#34;&#34;
        self.interpreter = type(interpretingExample)

    def verify(self, proposition):
        &#34;&#34;&#34;
        * boolean propositions will be returned as they are
        * numbers (float, integers) will return true if &gt; 0, 0 and negatives will return false
        * `nein`, `no`, `n`, `falsch`, `false`, `f` will return `False`
        * `ja`, `j`, `yes`, `y`, `wahr`, `w`, `true`, `t` will return `True`
        &#34;&#34;&#34;
        trueMatch = r&#34;^((t(rue)?)|(y(es)?)|(w(ahr)?)|(j(a)?))$&#34;
        falseMatch = r&#34;^((f((alse)|(alsch))?)|(n((o)|(ein))?))$&#34;
        if type(proposition) is bool:
            return proposition
        elif isinstance(proposition, (int, float)):
            return proposition &gt; 0
        elif type(proposition) is str:
            if re.match(trueMatch, proposition.strip(), re.IGNORECASE):
                return True
            elif re.match(falseMatch, proposition.strip(), re.IGNORECASE):
                return False
            elif self.interpreter != None:
                try:
                    return self.interpret(proposition)
                except:
                    pass
        raise Exception(&#39;No interpretion found for given proposition &#34;{}&#34;!&#39;.format(proposition))

    def interpret(self, proposition):
        &#34;&#34;&#34;
        Method for deep-diving proposition interpretation.
        Will check for `P1 o P2` with `P1`, `P2` propositions and `o` an operator
        out of:
        * `&lt;=` for “less or equal”
        * `&lt;` for “less”
        * `&gt;=` for “greater or equal”
        * `&gt;` for “greater”
        * `!=` for “not equal”
        * `==` for “equal”
        &#34;&#34;&#34;
        rx = r&#34;((((&lt;|&gt;)=?)|(!|=)=))&#34;
        cRx = re.compile(rx)
        splitting = []
        foundOperators = cRx.finditer(proposition)
        for idx, match in enumerate(foundOperators):
            s = match.start()
            e = match.end()
            splitting.append([s, e])
        checks = []
        s3 = 0
        for i, s in enumerate(splitting):
            s1 = s3
            s2 = s[0]
            s3 = s[1]
            if i != len(splitting) - 1:
                s4 = splitting[i + 1][0]
            else:
                s4 = len(proposition)
            checks.append(
                [
                    proposition[s1:s2].strip(),
                    proposition[s2:s3].strip(),
                    proposition[s3:s4].strip(),
                ]
            )
        verum = True
        for c in checks:
            o0 = self.interpreter(c[0])
            o1 = self.interpreter(c[2])
            if c[1] == &#34;&lt;=&#34;:
                verum = verum and o0 &lt;= o1
            elif c[1] == &#34;&lt;&#34;:
                verum = verum and o0 &lt; o1
            elif c[1] == &#34;&gt;=&#34;:
                verum = verum and o0 &gt;= o1
            elif c[1] == &#34;&gt;&#34;:
                verum = verum and o0 &gt; o1
            elif c[1] == &#34;!=&#34;:
                verum = verum and o0 != o1
            elif c[1] == &#34;==&#34;:
                verum = verum and o0 == o1
            else:
                raise Exception(&#39;&#34;{}&#34; is not interpretable!&#39;.format(proposition))
        return verum</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="SententialLogic.Truth.interpreter"><code class="name">var <span class="ident">interpreter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SententialLogic.Truth.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, proposition)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for deep-diving proposition interpretation.
Will check for <code>P1 o P2</code> with <code>P1</code>, <code>P2</code> propositions and <code>o</code> an operator
out of:
* <code>&lt;=</code> for “less or equal”
* <code>&lt;</code> for “less”
* <code>&gt;=</code> for “greater or equal”
* <code>&gt;</code> for “greater”
* <code>!=</code> for “not equal”
* <code>==</code> for “equal”</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, proposition):
    &#34;&#34;&#34;
    Method for deep-diving proposition interpretation.
    Will check for `P1 o P2` with `P1`, `P2` propositions and `o` an operator
    out of:
    * `&lt;=` for “less or equal”
    * `&lt;` for “less”
    * `&gt;=` for “greater or equal”
    * `&gt;` for “greater”
    * `!=` for “not equal”
    * `==` for “equal”
    &#34;&#34;&#34;
    rx = r&#34;((((&lt;|&gt;)=?)|(!|=)=))&#34;
    cRx = re.compile(rx)
    splitting = []
    foundOperators = cRx.finditer(proposition)
    for idx, match in enumerate(foundOperators):
        s = match.start()
        e = match.end()
        splitting.append([s, e])
    checks = []
    s3 = 0
    for i, s in enumerate(splitting):
        s1 = s3
        s2 = s[0]
        s3 = s[1]
        if i != len(splitting) - 1:
            s4 = splitting[i + 1][0]
        else:
            s4 = len(proposition)
        checks.append(
            [
                proposition[s1:s2].strip(),
                proposition[s2:s3].strip(),
                proposition[s3:s4].strip(),
            ]
        )
    verum = True
    for c in checks:
        o0 = self.interpreter(c[0])
        o1 = self.interpreter(c[2])
        if c[1] == &#34;&lt;=&#34;:
            verum = verum and o0 &lt;= o1
        elif c[1] == &#34;&lt;&#34;:
            verum = verum and o0 &lt; o1
        elif c[1] == &#34;&gt;=&#34;:
            verum = verum and o0 &gt;= o1
        elif c[1] == &#34;&gt;&#34;:
            verum = verum and o0 &gt; o1
        elif c[1] == &#34;!=&#34;:
            verum = verum and o0 != o1
        elif c[1] == &#34;==&#34;:
            verum = verum and o0 == o1
        else:
            raise Exception(&#39;&#34;{}&#34; is not interpretable!&#39;.format(proposition))
    return verum</code></pre>
</details>
</dd>
<dt id="SententialLogic.Truth.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, proposition)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>boolean propositions will be returned as they are</li>
<li>numbers (float, integers) will return true if &gt; 0, 0 and negatives will return false</li>
<li><code>nein</code>, <code>no</code>, <code>n</code>, <code>falsch</code>, <code>false</code>, <code>f</code> will return <code>False</code></li>
<li><code>ja</code>, <code>j</code>, <code>yes</code>, <code>y</code>, <code>wahr</code>, <code>w</code>, <code>true</code>, <code>t</code> will return <code>True</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify(self, proposition):
    &#34;&#34;&#34;
    * boolean propositions will be returned as they are
    * numbers (float, integers) will return true if &gt; 0, 0 and negatives will return false
    * `nein`, `no`, `n`, `falsch`, `false`, `f` will return `False`
    * `ja`, `j`, `yes`, `y`, `wahr`, `w`, `true`, `t` will return `True`
    &#34;&#34;&#34;
    trueMatch = r&#34;^((t(rue)?)|(y(es)?)|(w(ahr)?)|(j(a)?))$&#34;
    falseMatch = r&#34;^((f((alse)|(alsch))?)|(n((o)|(ein))?))$&#34;
    if type(proposition) is bool:
        return proposition
    elif isinstance(proposition, (int, float)):
        return proposition &gt; 0
    elif type(proposition) is str:
        if re.match(trueMatch, proposition.strip(), re.IGNORECASE):
            return True
        elif re.match(falseMatch, proposition.strip(), re.IGNORECASE):
            return False
        elif self.interpreter != None:
            try:
                return self.interpret(proposition)
            except:
                pass
    raise Exception(&#39;No interpretion found for given proposition &#34;{}&#34;!&#39;.format(proposition))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SententialLogic.Sentence" href="#SententialLogic.Sentence">Sentence</a></code></h4>
<ul class="">
<li><code><a title="SententialLogic.Sentence.atomizeBraces" href="#SententialLogic.Sentence.atomizeBraces">atomizeBraces</a></code></li>
<li><code><a title="SententialLogic.Sentence.atomized" href="#SententialLogic.Sentence.atomized">atomized</a></code></li>
<li><code><a title="SententialLogic.Sentence.getBraceIdx" href="#SententialLogic.Sentence.getBraceIdx">getBraceIdx</a></code></li>
<li><code><a title="SententialLogic.Sentence.getLiteral" href="#SententialLogic.Sentence.getLiteral">getLiteral</a></code></li>
<li><code><a title="SententialLogic.Sentence.isAtomic" href="#SententialLogic.Sentence.isAtomic">isAtomic</a></code></li>
<li><code><a title="SententialLogic.Sentence.sentence" href="#SententialLogic.Sentence.sentence">sentence</a></code></li>
<li><code><a title="SententialLogic.Sentence.truth" href="#SententialLogic.Sentence.truth">truth</a></code></li>
<li><code><a title="SententialLogic.Sentence.tsentence" href="#SententialLogic.Sentence.tsentence">tsentence</a></code></li>
<li><code><a title="SententialLogic.Sentence.verifier" href="#SententialLogic.Sentence.verifier">verifier</a></code></li>
<li><code><a title="SententialLogic.Sentence.verifyAllPropositions" href="#SententialLogic.Sentence.verifyAllPropositions">verifyAllPropositions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="SententialLogic.Truth" href="#SententialLogic.Truth">Truth</a></code></h4>
<ul class="">
<li><code><a title="SententialLogic.Truth.interpret" href="#SententialLogic.Truth.interpret">interpret</a></code></li>
<li><code><a title="SententialLogic.Truth.interpreter" href="#SententialLogic.Truth.interpreter">interpreter</a></code></li>
<li><code><a title="SententialLogic.Truth.verify" href="#SententialLogic.Truth.verify">verify</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>CSV API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CSV</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import pandas as pd
import math
import io
import logging


class CSV:
    &#34;&#34;&#34;Helper class for CSV files, where named columns will be retrievable

    The class needs the data being given as list of lists. Each row (outer list) contains multiple cells (inner list).
    If the data is given JSON like – as a list of dictionaries where each row (dictionary) contains the column names as keys and the cell content as value – the second constructor-parameter has to be set `True`.

    Attributes:
        specs: specifications for CSV, `delimiter` is defaulting to `;` and `linebreak` is defaulting to `\\n`.
    &#34;&#34;&#34;

    specs = {
        &#34;delimiter&#34;: &#34;;&#34;,
        &#34;linebreak&#34;: &#34;\n&#34;,
    }

    def __init__(self, data={}, jsonLike=False):
        self.data = {}
        self.rows = []
        self.rowCheck = False
        self.loadData(data, jsonLike)

    def __getitem__(self, index):
        self.csvRows()
        self.rowCheck = True
        return self.rows[index]

    def __len__(self):
        &#34;&#34;&#34;count rows in CSV

        Returns:
            int: numbers of rows in CSV
        &#34;&#34;&#34;
        return len(self.rows)

    def remove(self, row):
        &#34;&#34;&#34;remove row from CSV

        Args:
            row (dict): row object to remove from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        self.rows.remove(row)

    def pop(self, index):
        &#34;&#34;&#34;pop row from CSV – like from lists

        Args:
            index (int): index of row to pop

        Returns:
            dict: row removed / poped from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        return self.rows.pop(index)

    def __len__(self):
        &#34;&#34;&#34;count rows in CSV

        Returns:
            int: numbers of rows in CSV
        &#34;&#34;&#34;
        return len(self.rows)

    def remove(self, row):
        &#34;&#34;&#34;remove row from CSV

        Args:
            row (dict): row object to remove from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        self.rows.remove(row)

    def pop(self, index):
        &#34;&#34;&#34;pop row from CSV – like from lists

        Args:
            index (int): index of row to pop

        Returns:
            dict: row removed / poped from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        return self.rows.pop(index)

    def getCSV(self):
        &#34;&#34;&#34;get CSV data

        Return CSV data

        Returns:
            dict: keys are column titles, assigned lists are column values per row
        &#34;&#34;&#34;
        self.refreshFromRows()
        return self.data

    def loadData(self, data, jsonLike=False, skipRows=False):
        &#34;&#34;&#34;load data

        Method to load the data of the CSV.
        If data is a list of dicts, the dicts should have the keys in
        common and `jsonLike` shall be `True`.
        If the data is a dict of column-keys with a list of column-values
        where the index is the number of the row, `jsonLike` shall be `False`.

        Args:
            data (mixed): CSV data
            jsonLike (bool): is the data JSON like? (default: `False`)
            skipRows (bool): should the data be transferred into rows? DON&#39;T USE UNLESS YOU KNOW WHAT YOU&#39;RE DOING! (default: `False`)
        &#34;&#34;&#34;
        self.rowCheck = False
        if jsonLike:
            self.data = {}
            for row in data:
                try:
                    existingRowCount = len(next(iter(self.data.values())))
                except:
                    existingRowCount = 0
                keys = row.keys()
                for k in keys:
                    if k not in self.data:
                        if existingRowCount &gt; 0:
                            self.data[k] = [None] * existingRowCount
                        else:
                            self.data[k] = []
                for k in self.data.keys():
                    if k in row:
                        self.data[k].append(row[k])
                    else:
                        self.data[k].append(None)
        else:
            self.data = data

        if not skipRows:
            self.csvRows(force=True)

    def setSpec(self, spec, val):
        &#34;&#34;&#34;set specifications

        Method to set specifications for this CSV instance
        like the `delimiter` (default `;`) and the
        `linebreak` (default `\\n`)

        Args:
            spec(str): name of specification
            val(str): value for spec
        &#34;&#34;&#34;
        self.specs[spec] = val

    def readFile(self, filepath, delimiter=None):
        &#34;&#34;&#34;read CSV file

        Method to load especially a CSV file stored in the filesystem.

        Args:
            filepath (str): path to CSV file
            delimiter (str): delimiter to resolve the CSV data (default: `None`)
        &#34;&#34;&#34;
        self.readCSV(filepath, delimiter=delimiter, file=True)

    def readCSV(self, path_or_csvstring, delimiter=None, file=False):
        &#34;&#34;&#34;read CSV from string or file

        [description]

        Args:
            path_or_csvstring (string): either the path to the file to resolve or CSV data itself
            delimiter (str): delimiter to resolve the CSV data (default: `None`)
            file (bool): is it a file to read? (default: `False`)
        &#34;&#34;&#34;
        if delimiter == None:
            delimiter = self.specs[&#34;delimiter&#34;]
        if file:
            data = pd.read_csv(path_or_csvstring, delimiter=delimiter, low_memory=False)
        else:
            data = pd.read_csv(
                io.StringIO(path_or_csvstring),
                delimiter=delimiter,
                low_memory=False,
            )
        rows = {}
        for h in data.columns:
            rows[h] = data.get(h).to_list()
        self.data = rows

        self.csvRows(force=True)

    def csvRows(self, force=False):
        &#34;&#34;&#34;prepare rows variable

        Method to get row representation of CSV and prepare an additional variable
        `rows` that allows us to use `CSV` object as iterable.

        Args:
            force (bool): Shall the row representation be renewed by force? (default: `False`)

        Returns:
            list: list of rows in CSV
        &#34;&#34;&#34;
        if self.rows == []:
            force = True

        if force:
            self.rows = self.likeJSON()

        return self.rows

    def refreshFromRows(self):
        &#34;&#34;&#34;reload the CSV from rows

        When one iterates over the rows of a CSV class and changes values, e.g.
        adding new columns or manipulate values, the CSV object needs to be
        rebuilt from the rows ... that&#39;s what this method is doing.
        &#34;&#34;&#34;
        if self.rowCheck:
            self.loadData(data=self.rows, jsonLike=True, skipRows=True)
            self.rowCheck = False

    def likeJSON(self, keepEmpty=False, emptyValue=None):
        &#34;&#34;&#34;data to list of rows

        Method to get row representation of CSV.

        Args:
            keepEmpty (bool): if set to True, empty values are kept in row representation (default: `False`)
            emptyValue (mixed): value that should be used for kept empty values (default: `None`)

        Returns:
            list: list of rows in CSV
        &#34;&#34;&#34;
        self.refreshFromRows()

        jsonO = []
        keys = list(self.data.keys())
        if len(keys) &gt; 0:
            count = len(self.data[keys[0]])
            i = 0
            while i &lt; count:
                row = {}
                for key in keys:
                    value = self.data[key][i]
                    if value == &#34;&#34;:
                        if keepEmpty:
                            row[key] = emptyValue
                    else:
                        row[key] = value
                jsonO.append(row)
                i += 1
        return jsonO

    def writeFile(self, filepath, delimiter=None, linebreak=None):
        &#34;&#34;&#34;write CSV file

        Method to write out data of current object to a CSV file.

        Args:
            filepath (str): path to destination file
            delimiter (str): delimiter to be used for column separation in CSV representation (default: `None`)
            linebreak (str): linebreak to be used in CSV representation (default: `None`)
        &#34;&#34;&#34;
        self.refreshFromRows()

        if delimiter == None:
            delimiter = self.specs[&#34;delimiter&#34;]

        if linebreak == None:
            linebreak = self.specs[&#34;linebreak&#34;]

        combined = [[k] + v for k, v in self.data.items()]
        cols = pd.DataFrame(combined).T.values.tolist()
        rows = []

        for r in cols:
            i = 0

            for c in r:
                if c == None:
                    r[i] = &#34;&#34;
                i += 1
            rows.append(
                &#39;&#34;{values}&#34;&#39;.format(
                    values=&#39;&#34;{delim}&#34;&#39;.format(delim=delimiter).join(
                        [
                            str(c).replace(&#39;&#34;&#39;, &#39;&#34;&#34;&#34;&#39;)
                            if isinstance(c, str) or not math.isnan(c)
                            else &#34;&#34;
                            for c in r
                        ]
                    )
                )
            )

        with open(filepath, &#34;w&#34;) as csv_file:
            csv_file.write(linebreak.join(rows))


class ColumnHelper:
    &#34;&#34;&#34;Helper class for columns

    Attributes:
        ord0: integer representing the Unicode character `A`
    &#34;&#34;&#34;

    ord0 = ord(&#34;A&#34;)

    def xlsCol2Int(self, colName):
        &#34;&#34;&#34;XLS col to int

        According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
        method is meant to translate the alphabetic “number” to an integer.

        Args:
            colName (str): XLS column representation, e.g. `A` or `AA`, ...

        Returns:
            int: index representation as integer
        &#34;&#34;&#34;
        val = 0
        for ch in colName:  # base-26 decoding &#34;+1&#34;
            val = val * 26 + ord(ch) - self.ord0 + 1
        return val - 1

    def int2xlsCol(self, colInt):
        &#34;&#34;&#34;int index to XLS index

        According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
        function is meant to translate an integer to its alphabetic “number”
        representation.

        Args:
            colInt (int): index to be transferred to XLS column representation

        Returns:
            str: XLS column representation
        &#34;&#34;&#34;
        chars = []
        while True:
            if len(chars) &gt; 0:
                colInt = colInt - 1
            ch = colInt % 26
            chars.append(chr(ch + self.ord0))
            colInt = colInt // 26
            if not colInt:
                break
        return &#34;&#34;.join(reversed(chars))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CSV.CSV"><code class="flex name class">
<span>class <span class="ident">CSV</span></span>
<span>(</span><span>data={}, jsonLike=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class for CSV files, where named columns will be retrievable</p>
<p>The class needs the data being given as list of lists. Each row (outer list) contains multiple cells (inner list).
If the data is given JSON like – as a list of dictionaries where each row (dictionary) contains the column names as keys and the cell content as value – the second constructor-parameter has to be set <code>True</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>specs</code></strong></dt>
<dd>specifications for CSV, <code>delimiter</code> is defaulting to <code>;</code> and <code>linebreak</code> is defaulting to <code>\n</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CSV:
    &#34;&#34;&#34;Helper class for CSV files, where named columns will be retrievable

    The class needs the data being given as list of lists. Each row (outer list) contains multiple cells (inner list).
    If the data is given JSON like – as a list of dictionaries where each row (dictionary) contains the column names as keys and the cell content as value – the second constructor-parameter has to be set `True`.

    Attributes:
        specs: specifications for CSV, `delimiter` is defaulting to `;` and `linebreak` is defaulting to `\\n`.
    &#34;&#34;&#34;

    specs = {
        &#34;delimiter&#34;: &#34;;&#34;,
        &#34;linebreak&#34;: &#34;\n&#34;,
    }

    def __init__(self, data={}, jsonLike=False):
        self.data = {}
        self.rows = []
        self.rowCheck = False
        self.loadData(data, jsonLike)

    def __getitem__(self, index):
        self.csvRows()
        self.rowCheck = True
        return self.rows[index]

    def __len__(self):
        &#34;&#34;&#34;count rows in CSV

        Returns:
            int: numbers of rows in CSV
        &#34;&#34;&#34;
        return len(self.rows)

    def remove(self, row):
        &#34;&#34;&#34;remove row from CSV

        Args:
            row (dict): row object to remove from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        self.rows.remove(row)

    def pop(self, index):
        &#34;&#34;&#34;pop row from CSV – like from lists

        Args:
            index (int): index of row to pop

        Returns:
            dict: row removed / poped from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        return self.rows.pop(index)

    def __len__(self):
        &#34;&#34;&#34;count rows in CSV

        Returns:
            int: numbers of rows in CSV
        &#34;&#34;&#34;
        return len(self.rows)

    def remove(self, row):
        &#34;&#34;&#34;remove row from CSV

        Args:
            row (dict): row object to remove from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        self.rows.remove(row)

    def pop(self, index):
        &#34;&#34;&#34;pop row from CSV – like from lists

        Args:
            index (int): index of row to pop

        Returns:
            dict: row removed / poped from CSV
        &#34;&#34;&#34;
        self.rowCheck = True
        return self.rows.pop(index)

    def getCSV(self):
        &#34;&#34;&#34;get CSV data

        Return CSV data

        Returns:
            dict: keys are column titles, assigned lists are column values per row
        &#34;&#34;&#34;
        self.refreshFromRows()
        return self.data

    def loadData(self, data, jsonLike=False, skipRows=False):
        &#34;&#34;&#34;load data

        Method to load the data of the CSV.
        If data is a list of dicts, the dicts should have the keys in
        common and `jsonLike` shall be `True`.
        If the data is a dict of column-keys with a list of column-values
        where the index is the number of the row, `jsonLike` shall be `False`.

        Args:
            data (mixed): CSV data
            jsonLike (bool): is the data JSON like? (default: `False`)
            skipRows (bool): should the data be transferred into rows? DON&#39;T USE UNLESS YOU KNOW WHAT YOU&#39;RE DOING! (default: `False`)
        &#34;&#34;&#34;
        self.rowCheck = False
        if jsonLike:
            self.data = {}
            for row in data:
                try:
                    existingRowCount = len(next(iter(self.data.values())))
                except:
                    existingRowCount = 0
                keys = row.keys()
                for k in keys:
                    if k not in self.data:
                        if existingRowCount &gt; 0:
                            self.data[k] = [None] * existingRowCount
                        else:
                            self.data[k] = []
                for k in self.data.keys():
                    if k in row:
                        self.data[k].append(row[k])
                    else:
                        self.data[k].append(None)
        else:
            self.data = data

        if not skipRows:
            self.csvRows(force=True)

    def setSpec(self, spec, val):
        &#34;&#34;&#34;set specifications

        Method to set specifications for this CSV instance
        like the `delimiter` (default `;`) and the
        `linebreak` (default `\\n`)

        Args:
            spec(str): name of specification
            val(str): value for spec
        &#34;&#34;&#34;
        self.specs[spec] = val

    def readFile(self, filepath, delimiter=None):
        &#34;&#34;&#34;read CSV file

        Method to load especially a CSV file stored in the filesystem.

        Args:
            filepath (str): path to CSV file
            delimiter (str): delimiter to resolve the CSV data (default: `None`)
        &#34;&#34;&#34;
        self.readCSV(filepath, delimiter=delimiter, file=True)

    def readCSV(self, path_or_csvstring, delimiter=None, file=False):
        &#34;&#34;&#34;read CSV from string or file

        [description]

        Args:
            path_or_csvstring (string): either the path to the file to resolve or CSV data itself
            delimiter (str): delimiter to resolve the CSV data (default: `None`)
            file (bool): is it a file to read? (default: `False`)
        &#34;&#34;&#34;
        if delimiter == None:
            delimiter = self.specs[&#34;delimiter&#34;]
        if file:
            data = pd.read_csv(path_or_csvstring, delimiter=delimiter, low_memory=False)
        else:
            data = pd.read_csv(
                io.StringIO(path_or_csvstring),
                delimiter=delimiter,
                low_memory=False,
            )
        rows = {}
        for h in data.columns:
            rows[h] = data.get(h).to_list()
        self.data = rows

        self.csvRows(force=True)

    def csvRows(self, force=False):
        &#34;&#34;&#34;prepare rows variable

        Method to get row representation of CSV and prepare an additional variable
        `rows` that allows us to use `CSV` object as iterable.

        Args:
            force (bool): Shall the row representation be renewed by force? (default: `False`)

        Returns:
            list: list of rows in CSV
        &#34;&#34;&#34;
        if self.rows == []:
            force = True

        if force:
            self.rows = self.likeJSON()

        return self.rows

    def refreshFromRows(self):
        &#34;&#34;&#34;reload the CSV from rows

        When one iterates over the rows of a CSV class and changes values, e.g.
        adding new columns or manipulate values, the CSV object needs to be
        rebuilt from the rows ... that&#39;s what this method is doing.
        &#34;&#34;&#34;
        if self.rowCheck:
            self.loadData(data=self.rows, jsonLike=True, skipRows=True)
            self.rowCheck = False

    def likeJSON(self, keepEmpty=False, emptyValue=None):
        &#34;&#34;&#34;data to list of rows

        Method to get row representation of CSV.

        Args:
            keepEmpty (bool): if set to True, empty values are kept in row representation (default: `False`)
            emptyValue (mixed): value that should be used for kept empty values (default: `None`)

        Returns:
            list: list of rows in CSV
        &#34;&#34;&#34;
        self.refreshFromRows()

        jsonO = []
        keys = list(self.data.keys())
        if len(keys) &gt; 0:
            count = len(self.data[keys[0]])
            i = 0
            while i &lt; count:
                row = {}
                for key in keys:
                    value = self.data[key][i]
                    if value == &#34;&#34;:
                        if keepEmpty:
                            row[key] = emptyValue
                    else:
                        row[key] = value
                jsonO.append(row)
                i += 1
        return jsonO

    def writeFile(self, filepath, delimiter=None, linebreak=None):
        &#34;&#34;&#34;write CSV file

        Method to write out data of current object to a CSV file.

        Args:
            filepath (str): path to destination file
            delimiter (str): delimiter to be used for column separation in CSV representation (default: `None`)
            linebreak (str): linebreak to be used in CSV representation (default: `None`)
        &#34;&#34;&#34;
        self.refreshFromRows()

        if delimiter == None:
            delimiter = self.specs[&#34;delimiter&#34;]

        if linebreak == None:
            linebreak = self.specs[&#34;linebreak&#34;]

        combined = [[k] + v for k, v in self.data.items()]
        cols = pd.DataFrame(combined).T.values.tolist()
        rows = []

        for r in cols:
            i = 0

            for c in r:
                if c == None:
                    r[i] = &#34;&#34;
                i += 1
            rows.append(
                &#39;&#34;{values}&#34;&#39;.format(
                    values=&#39;&#34;{delim}&#34;&#39;.format(delim=delimiter).join(
                        [
                            str(c).replace(&#39;&#34;&#39;, &#39;&#34;&#34;&#34;&#39;)
                            if isinstance(c, str) or not math.isnan(c)
                            else &#34;&#34;
                            for c in r
                        ]
                    )
                )
            )

        with open(filepath, &#34;w&#34;) as csv_file:
            csv_file.write(linebreak.join(rows))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="CSV.CSV.specs"><code class="name">var <span class="ident">specs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CSV.CSV.csvRows"><code class="name flex">
<span>def <span class="ident">csvRows</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>prepare rows variable</p>
<p>Method to get row representation of CSV and prepare an additional variable
<code>rows</code> that allows us to use <code><a title="CSV.CSV" href="#CSV.CSV">CSV</a></code> object as iterable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code></dt>
<dd>Shall the row representation be renewed by force? (default: <code>False</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of rows in CSV</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csvRows(self, force=False):
    &#34;&#34;&#34;prepare rows variable

    Method to get row representation of CSV and prepare an additional variable
    `rows` that allows us to use `CSV` object as iterable.

    Args:
        force (bool): Shall the row representation be renewed by force? (default: `False`)

    Returns:
        list: list of rows in CSV
    &#34;&#34;&#34;
    if self.rows == []:
        force = True

    if force:
        self.rows = self.likeJSON()

    return self.rows</code></pre>
</details>
</dd>
<dt id="CSV.CSV.getCSV"><code class="name flex">
<span>def <span class="ident">getCSV</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get CSV data</p>
<p>Return CSV data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>keys are column titles, assigned lists are column values per row</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCSV(self):
    &#34;&#34;&#34;get CSV data

    Return CSV data

    Returns:
        dict: keys are column titles, assigned lists are column values per row
    &#34;&#34;&#34;
    self.refreshFromRows()
    return self.data</code></pre>
</details>
</dd>
<dt id="CSV.CSV.likeJSON"><code class="name flex">
<span>def <span class="ident">likeJSON</span></span>(<span>self, keepEmpty=False, emptyValue=None)</span>
</code></dt>
<dd>
<div class="desc"><p>data to list of rows</p>
<p>Method to get row representation of CSV.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keepEmpty</code></strong> :&ensp;<code>bool</code></dt>
<dd>if set to True, empty values are kept in row representation (default: <code>False</code>)</dd>
<dt><strong><code>emptyValue</code></strong> :&ensp;<code>mixed</code></dt>
<dd>value that should be used for kept empty values (default: <code>None</code>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of rows in CSV</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def likeJSON(self, keepEmpty=False, emptyValue=None):
    &#34;&#34;&#34;data to list of rows

    Method to get row representation of CSV.

    Args:
        keepEmpty (bool): if set to True, empty values are kept in row representation (default: `False`)
        emptyValue (mixed): value that should be used for kept empty values (default: `None`)

    Returns:
        list: list of rows in CSV
    &#34;&#34;&#34;
    self.refreshFromRows()

    jsonO = []
    keys = list(self.data.keys())
    if len(keys) &gt; 0:
        count = len(self.data[keys[0]])
        i = 0
        while i &lt; count:
            row = {}
            for key in keys:
                value = self.data[key][i]
                if value == &#34;&#34;:
                    if keepEmpty:
                        row[key] = emptyValue
                else:
                    row[key] = value
            jsonO.append(row)
            i += 1
    return jsonO</code></pre>
</details>
</dd>
<dt id="CSV.CSV.loadData"><code class="name flex">
<span>def <span class="ident">loadData</span></span>(<span>self, data, jsonLike=False, skipRows=False)</span>
</code></dt>
<dd>
<div class="desc"><p>load data</p>
<p>Method to load the data of the CSV.
If data is a list of dicts, the dicts should have the keys in
common and <code>jsonLike</code> shall be <code>True</code>.
If the data is a dict of column-keys with a list of column-values
where the index is the number of the row, <code>jsonLike</code> shall be <code>False</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>mixed</code></dt>
<dd>CSV data</dd>
<dt><strong><code>jsonLike</code></strong> :&ensp;<code>bool</code></dt>
<dd>is the data JSON like? (default: <code>False</code>)</dd>
<dt><strong><code>skipRows</code></strong> :&ensp;<code>bool</code></dt>
<dd>should the data be transferred into rows? DON'T USE UNLESS YOU KNOW WHAT YOU'RE DOING! (default: <code>False</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadData(self, data, jsonLike=False, skipRows=False):
    &#34;&#34;&#34;load data

    Method to load the data of the CSV.
    If data is a list of dicts, the dicts should have the keys in
    common and `jsonLike` shall be `True`.
    If the data is a dict of column-keys with a list of column-values
    where the index is the number of the row, `jsonLike` shall be `False`.

    Args:
        data (mixed): CSV data
        jsonLike (bool): is the data JSON like? (default: `False`)
        skipRows (bool): should the data be transferred into rows? DON&#39;T USE UNLESS YOU KNOW WHAT YOU&#39;RE DOING! (default: `False`)
    &#34;&#34;&#34;
    self.rowCheck = False
    if jsonLike:
        self.data = {}
        for row in data:
            try:
                existingRowCount = len(next(iter(self.data.values())))
            except:
                existingRowCount = 0
            keys = row.keys()
            for k in keys:
                if k not in self.data:
                    if existingRowCount &gt; 0:
                        self.data[k] = [None] * existingRowCount
                    else:
                        self.data[k] = []
            for k in self.data.keys():
                if k in row:
                    self.data[k].append(row[k])
                else:
                    self.data[k].append(None)
    else:
        self.data = data

    if not skipRows:
        self.csvRows(force=True)</code></pre>
</details>
</dd>
<dt id="CSV.CSV.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>pop row from CSV – like from lists</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of row to pop</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>row removed / poped from CSV</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, index):
    &#34;&#34;&#34;pop row from CSV – like from lists

    Args:
        index (int): index of row to pop

    Returns:
        dict: row removed / poped from CSV
    &#34;&#34;&#34;
    self.rowCheck = True
    return self.rows.pop(index)</code></pre>
</details>
</dd>
<dt id="CSV.CSV.readCSV"><code class="name flex">
<span>def <span class="ident">readCSV</span></span>(<span>self, path_or_csvstring, delimiter=None, file=False)</span>
</code></dt>
<dd>
<div class="desc"><p>read CSV from string or file</p>
<p>[description]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_or_csvstring</code></strong> :&ensp;<code>string</code></dt>
<dd>either the path to the file to resolve or CSV data itself</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str</code></dt>
<dd>delimiter to resolve the CSV data (default: <code>None</code>)</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>bool</code></dt>
<dd>is it a file to read? (default: <code>False</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readCSV(self, path_or_csvstring, delimiter=None, file=False):
    &#34;&#34;&#34;read CSV from string or file

    [description]

    Args:
        path_or_csvstring (string): either the path to the file to resolve or CSV data itself
        delimiter (str): delimiter to resolve the CSV data (default: `None`)
        file (bool): is it a file to read? (default: `False`)
    &#34;&#34;&#34;
    if delimiter == None:
        delimiter = self.specs[&#34;delimiter&#34;]
    if file:
        data = pd.read_csv(path_or_csvstring, delimiter=delimiter, low_memory=False)
    else:
        data = pd.read_csv(
            io.StringIO(path_or_csvstring),
            delimiter=delimiter,
            low_memory=False,
        )
    rows = {}
    for h in data.columns:
        rows[h] = data.get(h).to_list()
    self.data = rows

    self.csvRows(force=True)</code></pre>
</details>
</dd>
<dt id="CSV.CSV.readFile"><code class="name flex">
<span>def <span class="ident">readFile</span></span>(<span>self, filepath, delimiter=None)</span>
</code></dt>
<dd>
<div class="desc"><p>read CSV file</p>
<p>Method to load especially a CSV file stored in the filesystem.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>path to CSV file</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str</code></dt>
<dd>delimiter to resolve the CSV data (default: <code>None</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readFile(self, filepath, delimiter=None):
    &#34;&#34;&#34;read CSV file

    Method to load especially a CSV file stored in the filesystem.

    Args:
        filepath (str): path to CSV file
        delimiter (str): delimiter to resolve the CSV data (default: `None`)
    &#34;&#34;&#34;
    self.readCSV(filepath, delimiter=delimiter, file=True)</code></pre>
</details>
</dd>
<dt id="CSV.CSV.refreshFromRows"><code class="name flex">
<span>def <span class="ident">refreshFromRows</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>reload the CSV from rows</p>
<p>When one iterates over the rows of a CSV class and changes values, e.g.
adding new columns or manipulate values, the CSV object needs to be
rebuilt from the rows &hellip; that's what this method is doing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshFromRows(self):
    &#34;&#34;&#34;reload the CSV from rows

    When one iterates over the rows of a CSV class and changes values, e.g.
    adding new columns or manipulate values, the CSV object needs to be
    rebuilt from the rows ... that&#39;s what this method is doing.
    &#34;&#34;&#34;
    if self.rowCheck:
        self.loadData(data=self.rows, jsonLike=True, skipRows=True)
        self.rowCheck = False</code></pre>
</details>
</dd>
<dt id="CSV.CSV.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>remove row from CSV</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong> :&ensp;<code>dict</code></dt>
<dd>row object to remove from CSV</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, row):
    &#34;&#34;&#34;remove row from CSV

    Args:
        row (dict): row object to remove from CSV
    &#34;&#34;&#34;
    self.rowCheck = True
    self.rows.remove(row)</code></pre>
</details>
</dd>
<dt id="CSV.CSV.setSpec"><code class="name flex">
<span>def <span class="ident">setSpec</span></span>(<span>self, spec, val)</span>
</code></dt>
<dd>
<div class="desc"><p>set specifications</p>
<p>Method to set specifications for this CSV instance
like the <code>delimiter</code> (default <code>;</code>) and the
<code>linebreak</code> (default <code>\n</code>)</p>
<h2 id="args">Args</h2>
<p>spec(str): name of specification
val(str): value for spec</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSpec(self, spec, val):
    &#34;&#34;&#34;set specifications

    Method to set specifications for this CSV instance
    like the `delimiter` (default `;`) and the
    `linebreak` (default `\\n`)

    Args:
        spec(str): name of specification
        val(str): value for spec
    &#34;&#34;&#34;
    self.specs[spec] = val</code></pre>
</details>
</dd>
<dt id="CSV.CSV.writeFile"><code class="name flex">
<span>def <span class="ident">writeFile</span></span>(<span>self, filepath, delimiter=None, linebreak=None)</span>
</code></dt>
<dd>
<div class="desc"><p>write CSV file</p>
<p>Method to write out data of current object to a CSV file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>path to destination file</dd>
<dt><strong><code>delimiter</code></strong> :&ensp;<code>str</code></dt>
<dd>delimiter to be used for column separation in CSV representation (default: <code>None</code>)</dd>
<dt><strong><code>linebreak</code></strong> :&ensp;<code>str</code></dt>
<dd>linebreak to be used in CSV representation (default: <code>None</code>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeFile(self, filepath, delimiter=None, linebreak=None):
    &#34;&#34;&#34;write CSV file

    Method to write out data of current object to a CSV file.

    Args:
        filepath (str): path to destination file
        delimiter (str): delimiter to be used for column separation in CSV representation (default: `None`)
        linebreak (str): linebreak to be used in CSV representation (default: `None`)
    &#34;&#34;&#34;
    self.refreshFromRows()

    if delimiter == None:
        delimiter = self.specs[&#34;delimiter&#34;]

    if linebreak == None:
        linebreak = self.specs[&#34;linebreak&#34;]

    combined = [[k] + v for k, v in self.data.items()]
    cols = pd.DataFrame(combined).T.values.tolist()
    rows = []

    for r in cols:
        i = 0

        for c in r:
            if c == None:
                r[i] = &#34;&#34;
            i += 1
        rows.append(
            &#39;&#34;{values}&#34;&#39;.format(
                values=&#39;&#34;{delim}&#34;&#39;.format(delim=delimiter).join(
                    [
                        str(c).replace(&#39;&#34;&#39;, &#39;&#34;&#34;&#34;&#39;)
                        if isinstance(c, str) or not math.isnan(c)
                        else &#34;&#34;
                        for c in r
                    ]
                )
            )
        )

    with open(filepath, &#34;w&#34;) as csv_file:
        csv_file.write(linebreak.join(rows))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="CSV.ColumnHelper"><code class="flex name class">
<span>class <span class="ident">ColumnHelper</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class for columns</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ord0</code></strong></dt>
<dd>integer representing the Unicode character <code>A</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnHelper:
    &#34;&#34;&#34;Helper class for columns

    Attributes:
        ord0: integer representing the Unicode character `A`
    &#34;&#34;&#34;

    ord0 = ord(&#34;A&#34;)

    def xlsCol2Int(self, colName):
        &#34;&#34;&#34;XLS col to int

        According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
        method is meant to translate the alphabetic “number” to an integer.

        Args:
            colName (str): XLS column representation, e.g. `A` or `AA`, ...

        Returns:
            int: index representation as integer
        &#34;&#34;&#34;
        val = 0
        for ch in colName:  # base-26 decoding &#34;+1&#34;
            val = val * 26 + ord(ch) - self.ord0 + 1
        return val - 1

    def int2xlsCol(self, colInt):
        &#34;&#34;&#34;int index to XLS index

        According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
        function is meant to translate an integer to its alphabetic “number”
        representation.

        Args:
            colInt (int): index to be transferred to XLS column representation

        Returns:
            str: XLS column representation
        &#34;&#34;&#34;
        chars = []
        while True:
            if len(chars) &gt; 0:
                colInt = colInt - 1
            ch = colInt % 26
            chars.append(chr(ch + self.ord0))
            colInt = colInt // 26
            if not colInt:
                break
        return &#34;&#34;.join(reversed(chars))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="CSV.ColumnHelper.ord0"><code class="name">var <span class="ident">ord0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CSV.ColumnHelper.int2xlsCol"><code class="name flex">
<span>def <span class="ident">int2xlsCol</span></span>(<span>self, colInt)</span>
</code></dt>
<dd>
<div class="desc"><p>int index to XLS index</p>
<p>According to <code>A</code> is <code>0</code>, <code>Z</code> is <code>26</code>, <code>AA</code> is <code>27</code> and so on, this
function is meant to translate an integer to its alphabetic “number”
representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>colInt</code></strong> :&ensp;<code>int</code></dt>
<dd>index to be transferred to XLS column representation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>XLS column representation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int2xlsCol(self, colInt):
    &#34;&#34;&#34;int index to XLS index

    According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
    function is meant to translate an integer to its alphabetic “number”
    representation.

    Args:
        colInt (int): index to be transferred to XLS column representation

    Returns:
        str: XLS column representation
    &#34;&#34;&#34;
    chars = []
    while True:
        if len(chars) &gt; 0:
            colInt = colInt - 1
        ch = colInt % 26
        chars.append(chr(ch + self.ord0))
        colInt = colInt // 26
        if not colInt:
            break
    return &#34;&#34;.join(reversed(chars))</code></pre>
</details>
</dd>
<dt id="CSV.ColumnHelper.xlsCol2Int"><code class="name flex">
<span>def <span class="ident">xlsCol2Int</span></span>(<span>self, colName)</span>
</code></dt>
<dd>
<div class="desc"><p>XLS col to int</p>
<p>According to <code>A</code> is <code>0</code>, <code>Z</code> is <code>26</code>, <code>AA</code> is <code>27</code> and so on, this
method is meant to translate the alphabetic “number” to an integer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>colName</code></strong> :&ensp;<code>str</code></dt>
<dd>XLS column representation, e.g. <code>A</code> or <code>AA</code>, &hellip;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>index representation as integer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xlsCol2Int(self, colName):
    &#34;&#34;&#34;XLS col to int

    According to `A` is `0`, `Z` is `26`, `AA` is `27` and so on, this
    method is meant to translate the alphabetic “number” to an integer.

    Args:
        colName (str): XLS column representation, e.g. `A` or `AA`, ...

    Returns:
        int: index representation as integer
    &#34;&#34;&#34;
    val = 0
    for ch in colName:  # base-26 decoding &#34;+1&#34;
        val = val * 26 + ord(ch) - self.ord0 + 1
    return val - 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CSV.CSV" href="#CSV.CSV">CSV</a></code></h4>
<ul class="two-column">
<li><code><a title="CSV.CSV.csvRows" href="#CSV.CSV.csvRows">csvRows</a></code></li>
<li><code><a title="CSV.CSV.getCSV" href="#CSV.CSV.getCSV">getCSV</a></code></li>
<li><code><a title="CSV.CSV.likeJSON" href="#CSV.CSV.likeJSON">likeJSON</a></code></li>
<li><code><a title="CSV.CSV.loadData" href="#CSV.CSV.loadData">loadData</a></code></li>
<li><code><a title="CSV.CSV.pop" href="#CSV.CSV.pop">pop</a></code></li>
<li><code><a title="CSV.CSV.readCSV" href="#CSV.CSV.readCSV">readCSV</a></code></li>
<li><code><a title="CSV.CSV.readFile" href="#CSV.CSV.readFile">readFile</a></code></li>
<li><code><a title="CSV.CSV.refreshFromRows" href="#CSV.CSV.refreshFromRows">refreshFromRows</a></code></li>
<li><code><a title="CSV.CSV.remove" href="#CSV.CSV.remove">remove</a></code></li>
<li><code><a title="CSV.CSV.setSpec" href="#CSV.CSV.setSpec">setSpec</a></code></li>
<li><code><a title="CSV.CSV.specs" href="#CSV.CSV.specs">specs</a></code></li>
<li><code><a title="CSV.CSV.writeFile" href="#CSV.CSV.writeFile">writeFile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CSV.ColumnHelper" href="#CSV.ColumnHelper">ColumnHelper</a></code></h4>
<ul class="">
<li><code><a title="CSV.ColumnHelper.int2xlsCol" href="#CSV.ColumnHelper.int2xlsCol">int2xlsCol</a></code></li>
<li><code><a title="CSV.ColumnHelper.ord0" href="#CSV.ColumnHelper.ord0">ord0</a></code></li>
<li><code><a title="CSV.ColumnHelper.xlsCol2Int" href="#CSV.ColumnHelper.xlsCol2Int">xlsCol2Int</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>